module.exports =
/******/ (function (modules, runtime) { // webpackBootstrap
/******/ 	"use strict";
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if (installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
        /******/
      }
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
        /******/
      };
/******/
/******/ 		// Execute the module function
/******/ 		var threw = true;
/******/ 		try {
/******/ 			modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 			threw = false;
        /******/
      } finally {
/******/ 			if (threw) delete installedModules[moduleId];
        /******/
      }
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
      /******/
    }
/******/
/******/
/******/ 	__webpack_require__.ab = __dirname + "/";
/******/
/******/ 	// the startup function
/******/ 	function startup() {
/******/ 		// Load entry module and return exports
/******/ 		return __webpack_require__(104);
      /******/
    };
/******/
/******/ 	// run startup
/******/ 	return startup();
    /******/
  })
/************************************************************************/
/******/({

/***/ 26:
/***/ (function (module, __unusedexports, __webpack_require__) {

        "use strict";


        var enhanceError = __webpack_require__(369);

        /**
         * Create an Error with the specified message, config, error code, request and response.
         *
         * @param {string} message The error message.
         * @param {Object} config The config.
         * @param {string} [code] The error code (for example, 'ECONNABORTED').
         * @param {Object} [request] The request.
         * @param {Object} [response] The response.
         * @returns {Error} The created error.
         */
        module.exports = function createError(message, config, code, request, response) {
          var error = new Error(message);
          return enhanceError(error, config, code, request, response);
        };


        /***/
      }),

/***/ 35:
/***/ (function (module, __unusedexports, __webpack_require__) {

        "use strict";


        var bind = __webpack_require__(727);

        /*global toString:true*/

        // utils is a library of generic helper functions non-specific to axios

        var toString = Object.prototype.toString;

        /**
         * Determine if a value is an Array
         *
         * @param {Object} val The value to test
         * @returns {boolean} True if value is an Array, otherwise false
         */
        function isArray(val) {
          return toString.call(val) === '[object Array]';
        }

        /**
         * Determine if a value is undefined
         *
         * @param {Object} val The value to test
         * @returns {boolean} True if the value is undefined, otherwise false
         */
        function isUndefined(val) {
          return typeof val === 'undefined';
        }

        /**
         * Determine if a value is a Buffer
         *
         * @param {Object} val The value to test
         * @returns {boolean} True if value is a Buffer, otherwise false
         */
        function isBuffer(val) {
          return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
            && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
        }

        /**
         * Determine if a value is an ArrayBuffer
         *
         * @param {Object} val The value to test
         * @returns {boolean} True if value is an ArrayBuffer, otherwise false
         */
        function isArrayBuffer(val) {
          return toString.call(val) === '[object ArrayBuffer]';
        }

        /**
         * Determine if a value is a FormData
         *
         * @param {Object} val The value to test
         * @returns {boolean} True if value is an FormData, otherwise false
         */
        function isFormData(val) {
          return (typeof FormData !== 'undefined') && (val instanceof FormData);
        }

        /**
         * Determine if a value is a view on an ArrayBuffer
         *
         * @param {Object} val The value to test
         * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
         */
        function isArrayBufferView(val) {
          var result;
          if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
            result = ArrayBuffer.isView(val);
          } else {
            result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
          }
          return result;
        }

        /**
         * Determine if a value is a String
         *
         * @param {Object} val The value to test
         * @returns {boolean} True if value is a String, otherwise false
         */
        function isString(val) {
          return typeof val === 'string';
        }

        /**
         * Determine if a value is a Number
         *
         * @param {Object} val The value to test
         * @returns {boolean} True if value is a Number, otherwise false
         */
        function isNumber(val) {
          return typeof val === 'number';
        }

        /**
         * Determine if a value is an Object
         *
         * @param {Object} val The value to test
         * @returns {boolean} True if value is an Object, otherwise false
         */
        function isObject(val) {
          return val !== null && typeof val === 'object';
        }

        /**
         * Determine if a value is a plain Object
         *
         * @param {Object} val The value to test
         * @return {boolean} True if value is a plain Object, otherwise false
         */
        function isPlainObject(val) {
          if (toString.call(val) !== '[object Object]') {
            return false;
          }

          var prototype = Object.getPrototypeOf(val);
          return prototype === null || prototype === Object.prototype;
        }

        /**
         * Determine if a value is a Date
         *
         * @param {Object} val The value to test
         * @returns {boolean} True if value is a Date, otherwise false
         */
        function isDate(val) {
          return toString.call(val) === '[object Date]';
        }

        /**
         * Determine if a value is a File
         *
         * @param {Object} val The value to test
         * @returns {boolean} True if value is a File, otherwise false
         */
        function isFile(val) {
          return toString.call(val) === '[object File]';
        }

        /**
         * Determine if a value is a Blob
         *
         * @param {Object} val The value to test
         * @returns {boolean} True if value is a Blob, otherwise false
         */
        function isBlob(val) {
          return toString.call(val) === '[object Blob]';
        }

        /**
         * Determine if a value is a Function
         *
         * @param {Object} val The value to test
         * @returns {boolean} True if value is a Function, otherwise false
         */
        function isFunction(val) {
          return toString.call(val) === '[object Function]';
        }

        /**
         * Determine if a value is a Stream
         *
         * @param {Object} val The value to test
         * @returns {boolean} True if value is a Stream, otherwise false
         */
        function isStream(val) {
          return isObject(val) && isFunction(val.pipe);
        }

        /**
         * Determine if a value is a URLSearchParams object
         *
         * @param {Object} val The value to test
         * @returns {boolean} True if value is a URLSearchParams object, otherwise false
         */
        function isURLSearchParams(val) {
          return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
        }

        /**
         * Trim excess whitespace off the beginning and end of a string
         *
         * @param {String} str The String to trim
         * @returns {String} The String freed of excess whitespace
         */
        function trim(str) {
          return str.replace(/^\s*/, '').replace(/\s*$/, '');
        }

        /**
         * Determine if we're running in a standard browser environment
         *
         * This allows axios to run in a web worker, and react-native.
         * Both environments support XMLHttpRequest, but not fully standard globals.
         *
         * web workers:
         *  typeof window -> undefined
         *  typeof document -> undefined
         *
         * react-native:
         *  navigator.product -> 'ReactNative'
         * nativescript
         *  navigator.product -> 'NativeScript' or 'NS'
         */
        function isStandardBrowserEnv() {
          if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||
            navigator.product === 'NativeScript' ||
            navigator.product === 'NS')) {
            return false;
          }
          return (
            typeof window !== 'undefined' &&
            typeof document !== 'undefined'
          );
        }

        /**
         * Iterate over an Array or an Object invoking a function for each item.
         *
         * If `obj` is an Array callback will be called passing
         * the value, index, and complete array for each item.
         *
         * If 'obj' is an Object callback will be called passing
         * the value, key, and complete object for each property.
         *
         * @param {Object|Array} obj The object to iterate
         * @param {Function} fn The callback to invoke for each item
         */
        function forEach(obj, fn) {
          // Don't bother if no value provided
          if (obj === null || typeof obj === 'undefined') {
            return;
          }

          // Force an array if not already something iterable
          if (typeof obj !== 'object') {
            /*eslint no-param-reassign:0*/
            obj = [obj];
          }

          if (isArray(obj)) {
            // Iterate over array values
            for (var i = 0, l = obj.length; i < l; i++) {
              fn.call(null, obj[i], i, obj);
            }
          } else {
            // Iterate over object keys
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key)) {
                fn.call(null, obj[key], key, obj);
              }
            }
          }
        }

        /**
         * Accepts varargs expecting each argument to be an object, then
         * immutably merges the properties of each object and returns result.
         *
         * When multiple objects contain the same key the later object in
         * the arguments list will take precedence.
         *
         * Example:
         *
         * ```js
         * var result = merge({foo: 123}, {foo: 456});
         * console.log(result.foo); // outputs 456
         * ```
         *
         * @param {Object} obj1 Object to merge
         * @returns {Object} Result of all merge properties
         */
        function merge(/* obj1, obj2, obj3, ... */) {
          var result = {};
          function assignValue(val, key) {
            if (isPlainObject(result[key]) && isPlainObject(val)) {
              result[key] = merge(result[key], val);
            } else if (isPlainObject(val)) {
              result[key] = merge({}, val);
            } else if (isArray(val)) {
              result[key] = val.slice();
            } else {
              result[key] = val;
            }
          }

          for (var i = 0, l = arguments.length; i < l; i++) {
            forEach(arguments[i], assignValue);
          }
          return result;
        }

        /**
         * Extends object a by mutably adding to it the properties of object b.
         *
         * @param {Object} a The object to be extended
         * @param {Object} b The object to copy properties from
         * @param {Object} thisArg The object to bind function to
         * @return {Object} The resulting value of object a
         */
        function extend(a, b, thisArg) {
          forEach(b, function assignValue(val, key) {
            if (thisArg && typeof val === 'function') {
              a[key] = bind(val, thisArg);
            } else {
              a[key] = val;
            }
          });
          return a;
        }

        /**
         * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
         *
         * @param {string} content with BOM
         * @return {string} content value without BOM
         */
        function stripBOM(content) {
          if (content.charCodeAt(0) === 0xFEFF) {
            content = content.slice(1);
          }
          return content;
        }

        module.exports = {
          isArray: isArray,
          isArrayBuffer: isArrayBuffer,
          isBuffer: isBuffer,
          isFormData: isFormData,
          isArrayBufferView: isArrayBufferView,
          isString: isString,
          isNumber: isNumber,
          isObject: isObject,
          isPlainObject: isPlainObject,
          isUndefined: isUndefined,
          isDate: isDate,
          isFile: isFile,
          isBlob: isBlob,
          isFunction: isFunction,
          isStream: isStream,
          isURLSearchParams: isURLSearchParams,
          isStandardBrowserEnv: isStandardBrowserEnv,
          forEach: forEach,
          merge: merge,
          extend: extend,
          trim: trim,
          stripBOM: stripBOM
        };


        /***/
      }),

/***/ 53:
/***/ (function (module, __unusedexports, __webpack_require__) {

        module.exports = __webpack_require__(352);

        /***/
      }),

/***/ 87:
/***/ (function (module) {

        module.exports = require("os");

        /***/
      }),

/***/ 104:
/***/ (function (__unusedmodule, __unusedexports, __webpack_require__) {

        const core = __webpack_require__(470);
        const axios = __webpack_require__(53);
        const Humanize = __webpack_require__(481);
        const fs = __webpack_require__(747);
        const exec = __webpack_require__(898);

        const TODOIST_API_KEY = core.getInput("TODOIST_API_KEY");
        const PREMIUM = core.getInput("PREMIUM");

        async function main() {
          const stats = await axios(`https://api.todoist.com/sync/v9/completed/get_stats?token=${TODOIST_API_KEY}`);
          await updateReadme(stats.data);
        }

        let todoist = [];
        let jobFailFlag = false;
        const README_FILE_PATH = './README.md';

        async function updateReadme(data) {


          const { karma, completed_count, days_items, goals, week_items } = data;

          const karmaPoint = [`🏆  ${Humanize.intComma(karma)} Karma Points`];
          todoist.push(karmaPoint);

          const dailyGoal = [
            `🌸  Completed ${days_items[0].total_completed.toString()} tasks today`,
          ];
          todoist.push(dailyGoal);

          if (PREMIUM) {
            const weekItems = [`🗓  Completed ${week_items[0].total_completed.toString()} tasks this week`];
            todoist.push(weekItems);
          }

          const totalTasks = [`✅  Completed ${Humanize.intComma(completed_count)} tasks so far`];
          todoist.push(totalTasks);

          const longestStreak = [
            `⏳  Longest streak is ${goals.max_daily_streak.count} days`,
          ];
          todoist.push(longestStreak);

          if (todoist.length == 0) return;

          if (todoist.length > 0) {
            console.log(todoist.length);
            // const showTasks = todoist.reduce((todo, cur, index) => {
            //   return todo + `\n${cur}        ` + (((index + 1) === todoist.length) ? '\n' : '');
            // })
            const readmeData = fs.readFileSync(README_FILE_PATH, "utf8");


            const newReadme = buildReadme(readmeData, todoist.join("           \n"));
            if (newReadme !== readmeData) {
              core.info('Writing to ' + README_FILE_PATH);
              fs.writeFileSync(README_FILE_PATH, newReadme);
              if (!process.env.TEST_MODE) {
                commitReadme();
              }
            } else {
              core.info('No change detected, skipping');
              process.exit(0);
            }
          }
          else {
            core.info("Nothing fetched");
            process.exit(jobFailFlag ? 1 : 0);
          }
        }

        // console.log(todoist.length);




        const buildReadme = (prevReadmeContent, newReadmeContent) => {
          const tagToLookFor = '<!-- TODO-IST:';
          const closingTag = '-->';
          const startOfOpeningTagIndex = prevReadmeContent.indexOf(
            `${tagToLookFor}START`,
          );
          const endOfOpeningTagIndex = prevReadmeContent.indexOf(
            closingTag,
            startOfOpeningTagIndex,
          );
          const startOfClosingTagIndex = prevReadmeContent.indexOf(
            `${tagToLookFor}END`,
            endOfOpeningTagIndex,
          );
          if (
            startOfOpeningTagIndex === -1 ||
            endOfOpeningTagIndex === -1 ||
            startOfClosingTagIndex === -1
          ) {
            core.error(
              `Cannot find the comment tag on the readme:\n<!-- ${tagToLookFor}:START -->\n<!-- ${tagToLookFor}:END -->`
            );
            process.exit(1);
          }
          return [
            prevReadmeContent.slice(0, endOfOpeningTagIndex + closingTag.length),
            '\n',
            newReadmeContent,
            '\n',
            prevReadmeContent.slice(startOfClosingTagIndex),
          ].join('');
        };

        const commitReadme = async () => {
          // Getting config
          const committerUsername = core.getInput('committer_username');
          const committerEmail = core.getInput('committer_email');
          const commitMessage = 'Todoist 🧾 Updated! 🎉';
          // Doing commit and push
          await exec('git', [
            'config',
            '--global',
            'user.email',
            committerEmail,
          ]);
          await exec('git', ['config', '--global', 'user.name', committerUsername]);
          await exec('git', ['add', README_FILE_PATH]);
          await exec('git', ['commit', '-m', commitMessage]);
          // await exec('git', ['fetch']);
          await exec('git', ['push']);
          core.info("Readme updated successfully.");
          // Making job fail if one of the source fails
          process.exit(jobFailFlag ? 1 : 0);
        };

        (async () => {
          await main();
        })();

        /***/
      }),

/***/ 129:
/***/ (function (module) {

        module.exports = require("child_process");

        /***/
      }),

/***/ 133:
/***/ (function (module, __unusedexports, __webpack_require__) {

        "use strict";


        var utils = __webpack_require__(35);

        function encode(val) {
          return encodeURIComponent(val).
            replace(/%3A/gi, ':').
            replace(/%24/g, '$').
            replace(/%2C/gi, ',').
            replace(/%20/g, '+').
            replace(/%5B/gi, '[').
            replace(/%5D/gi, ']');
        }

        /**
         * Build a URL by appending params to the end
         *
         * @param {string} url The base of the url (e.g., http://www.google.com)
         * @param {object} [params] The params to be appended
         * @returns {string} The formatted url
         */
        module.exports = function buildURL(url, params, paramsSerializer) {
          /*eslint no-param-reassign:0*/
          if (!params) {
            return url;
          }

          var serializedParams;
          if (paramsSerializer) {
            serializedParams = paramsSerializer(params);
          } else if (utils.isURLSearchParams(params)) {
            serializedParams = params.toString();
          } else {
            var parts = [];

            utils.forEach(params, function serialize(val, key) {
              if (val === null || typeof val === 'undefined') {
                return;
              }

              if (utils.isArray(val)) {
                key = key + '[]';
              } else {
                val = [val];
              }

              utils.forEach(val, function parseValue(v) {
                if (utils.isDate(v)) {
                  v = v.toISOString();
                } else if (utils.isObject(v)) {
                  v = JSON.stringify(v);
                }
                parts.push(encode(key) + '=' + encode(v));
              });
            });

            serializedParams = parts.join('&');
          }

          if (serializedParams) {
            var hashmarkIndex = url.indexOf('#');
            if (hashmarkIndex !== -1) {
              url = url.slice(0, hashmarkIndex);
            }

            url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
          }

          return url;
        };


        /***/
      }),

/***/ 137:
/***/ (function (module, __unusedexports, __webpack_require__) {

        "use strict";


        var Cancel = __webpack_require__(826);

        /**
         * A `CancelToken` is an object that can be used to request cancellation of an operation.
         *
         * @class
         * @param {Function} executor The executor function.
         */
        function CancelToken(executor) {
          if (typeof executor !== 'function') {
            throw new TypeError('executor must be a function.');
          }

          var resolvePromise;
          this.promise = new Promise(function promiseExecutor(resolve) {
            resolvePromise = resolve;
          });

          var token = this;
          executor(function cancel(message) {
            if (token.reason) {
              // Cancellation has already been requested
              return;
            }

            token.reason = new Cancel(message);
            resolvePromise(token.reason);
          });
        }

        /**
         * Throws a `Cancel` if cancellation has been requested.
         */
        CancelToken.prototype.throwIfRequested = function throwIfRequested() {
          if (this.reason) {
            throw this.reason;
          }
        };

        /**
         * Returns an object that contains a new `CancelToken` and a function that, when called,
         * cancels the `CancelToken`.
         */
        CancelToken.source = function source() {
          var cancel;
          var token = new CancelToken(function executor(c) {
            cancel = c;
          });
          return {
            token: token,
            cancel: cancel
          };
        };

        module.exports = CancelToken;


        /***/
      }),

/***/ 211:
/***/ (function (module) {

        module.exports = require("https");

        /***/
      }),

/***/ 219:
/***/ (function (module, __unusedexports, __webpack_require__) {

        "use strict";


        var utils = __webpack_require__(35);
        var settle = __webpack_require__(564);
        var cookies = __webpack_require__(864);
        var buildURL = __webpack_require__(133);
        var buildFullPath = __webpack_require__(960);
        var parseHeaders = __webpack_require__(631);
        var isURLSameOrigin = __webpack_require__(688);
        var createError = __webpack_require__(26);

        module.exports = function xhrAdapter(config) {
          return new Promise(function dispatchXhrRequest(resolve, reject) {
            var requestData = config.data;
            var requestHeaders = config.headers;

            if (utils.isFormData(requestData)) {
              delete requestHeaders['Content-Type']; // Let the browser set it
            }

            if (
              (utils.isBlob(requestData) || utils.isFile(requestData)) &&
              requestData.type
            ) {
              delete requestHeaders['Content-Type']; // Let the browser set it
            }

            var request = new XMLHttpRequest();

            // HTTP basic authentication
            if (config.auth) {
              var username = config.auth.username || '';
              var password = unescape(encodeURIComponent(config.auth.password)) || '';
              requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
            }

            var fullPath = buildFullPath(config.baseURL, config.url);
            request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

            // Set the request timeout in MS
            request.timeout = config.timeout;

            // Listen for ready state
            request.onreadystatechange = function handleLoad() {
              if (!request || request.readyState !== 4) {
                return;
              }

              // The request errored out and we didn't get a response, this will be
              // handled by onerror instead
              // With one exception: request that using file: protocol, most browsers
              // will return status as 0 even though it's a successful request
              if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
                return;
              }

              // Prepare the response
              var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
              var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
              var response = {
                data: responseData,
                status: request.status,
                statusText: request.statusText,
                headers: responseHeaders,
                config: config,
                request: request
              };

              settle(resolve, reject, response);

              // Clean up request
              request = null;
            };

            // Handle browser request cancellation (as opposed to a manual cancellation)
            request.onabort = function handleAbort() {
              if (!request) {
                return;
              }

              reject(createError('Request aborted', config, 'ECONNABORTED', request));

              // Clean up request
              request = null;
            };

            // Handle low level network errors
            request.onerror = function handleError() {
              // Real errors are hidden from us by the browser
              // onerror should only fire if it's a network error
              reject(createError('Network Error', config, null, request));

              // Clean up request
              request = null;
            };

            // Handle timeout
            request.ontimeout = function handleTimeout() {
              var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';
              if (config.timeoutErrorMessage) {
                timeoutErrorMessage = config.timeoutErrorMessage;
              }
              reject(createError(timeoutErrorMessage, config, 'ECONNABORTED',
                request));

              // Clean up request
              request = null;
            };

            // Add xsrf header
            // This is only done if running in a standard browser environment.
            // Specifically not if we're in a web worker, or react-native.
            if (utils.isStandardBrowserEnv()) {
              // Add xsrf header
              var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?
                cookies.read(config.xsrfCookieName) :
                undefined;

              if (xsrfValue) {
                requestHeaders[config.xsrfHeaderName] = xsrfValue;
              }
            }

            // Add headers to the request
            if ('setRequestHeader' in request) {
              utils.forEach(requestHeaders, function setRequestHeader(val, key) {
                if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
                  // Remove Content-Type if data is undefined
                  delete requestHeaders[key];
                } else {
                  // Otherwise add header to the request
                  request.setRequestHeader(key, val);
                }
              });
            }

            // Add withCredentials to request if needed
            if (!utils.isUndefined(config.withCredentials)) {
              request.withCredentials = !!config.withCredentials;
            }

            // Add responseType to request if needed
            if (config.responseType) {
              try {
                request.responseType = config.responseType;
              } catch (e) {
                // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
                // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
                if (config.responseType !== 'json') {
                  throw e;
                }
              }
            }

            // Handle progress if needed
            if (typeof config.onDownloadProgress === 'function') {
              request.addEventListener('progress', config.onDownloadProgress);
            }

            // Not all browsers support upload events
            if (typeof config.onUploadProgress === 'function' && request.upload) {
              request.upload.addEventListener('progress', config.onUploadProgress);
            }

            if (config.cancelToken) {
              // Handle cancellation
              config.cancelToken.promise.then(function onCanceled(cancel) {
                if (!request) {
                  return;
                }

                request.abort();
                reject(cancel);
                // Clean up request
                request = null;
              });
            }

            if (!requestData) {
              requestData = null;
            }

            // Send the request
            request.send(requestData);
          });
        };


        /***/
      }),

/***/ 283:
/***/ (function (module, __unusedexports, __webpack_require__) {

        "use strict";


        var utils = __webpack_require__(35);

        function InterceptorManager() {
          this.handlers = [];
        }

        /**
         * Add a new interceptor to the stack
         *
         * @param {Function} fulfilled The function to handle `then` for a `Promise`
         * @param {Function} rejected The function to handle `reject` for a `Promise`
         *
         * @return {Number} An ID used to remove interceptor later
         */
        InterceptorManager.prototype.use = function use(fulfilled, rejected) {
          this.handlers.push({
            fulfilled: fulfilled,
            rejected: rejected
          });
          return this.handlers.length - 1;
        };

        /**
         * Remove an interceptor from the stack
         *
         * @param {Number} id The ID that was returned by `use`
         */
        InterceptorManager.prototype.eject = function eject(id) {
          if (this.handlers[id]) {
            this.handlers[id] = null;
          }
        };

        /**
         * Iterate over all the registered interceptors
         *
         * This method is particularly useful for skipping over any
         * interceptors that may have become `null` calling `eject`.
         *
         * @param {Function} fn The function to call for each interceptor
         */
        InterceptorManager.prototype.forEach = function forEach(fn) {
          utils.forEach(this.handlers, function forEachHandler(h) {
            if (h !== null) {
              fn(h);
            }
          });
        };

        module.exports = InterceptorManager;


        /***/
      }),

/***/ 352:
/***/ (function (module, __unusedexports, __webpack_require__) {

        "use strict";


        var utils = __webpack_require__(35);
        var bind = __webpack_require__(727);
        var Axios = __webpack_require__(779);
        var mergeConfig = __webpack_require__(825);
        var defaults = __webpack_require__(529);

        /**
         * Create an instance of Axios
         *
         * @param {Object} defaultConfig The default config for the instance
         * @return {Axios} A new instance of Axios
         */
        function createInstance(defaultConfig) {
          var context = new Axios(defaultConfig);
          var instance = bind(Axios.prototype.request, context);

          // Copy axios.prototype to instance
          utils.extend(instance, Axios.prototype, context);

          // Copy context to instance
          utils.extend(instance, context);

          return instance;
        }

        // Create the default instance to be exported
        var axios = createInstance(defaults);

        // Expose Axios class to allow class inheritance
        axios.Axios = Axios;

        // Factory for creating new instances
        axios.create = function create(instanceConfig) {
          return createInstance(mergeConfig(axios.defaults, instanceConfig));
        };

        // Expose Cancel & CancelToken
        axios.Cancel = __webpack_require__(826);
        axios.CancelToken = __webpack_require__(137);
        axios.isCancel = __webpack_require__(732);

        // Expose all/spread
        axios.all = function all(promises) {
          return Promise.all(promises);
        };
        axios.spread = __webpack_require__(879);

        module.exports = axios;

        // Allow use of default import syntax in TypeScript
        module.exports.default = axios;


        /***/
      }),

/***/ 357:
/***/ (function (module) {

        module.exports = require("assert");

        /***/
      }),

/***/ 361:
/***/ (function (module) {

        module.exports = { "_from": "axios", "_id": "axios@0.20.0", "_inBundle": false, "_integrity": "sha512-ANA4rr2BDcmmAQLOKft2fufrtuvlqR+cXNNinUmvfeSNCOF98PZL+7M/v1zIdGo7OLjEA9J2gXJL+j4zGsl0bA==", "_location": "/axios", "_phantomChildren": {}, "_requested": { "type": "tag", "registry": true, "raw": "axios", "name": "axios", "escapedName": "axios", "rawSpec": "", "saveSpec": null, "fetchSpec": "latest" }, "_requiredBy": ["#USER", "/"], "_resolved": "https://registry.npmjs.org/axios/-/axios-0.20.0.tgz", "_shasum": "057ba30f04884694993a8cd07fa394cff11c50bd", "_spec": "axios", "_where": "", "author": { "name": "Matt Zabriskie" }, "browser": { "./lib/adapters/http.js": "./lib/adapters/xhr.js" }, "bugs": { "url": "https://github.com/axios/axios/issues" }, "bundleDependencies": false, "bundlesize": [{ "path": "./dist/axios.min.js", "threshold": "5kB" }], "dependencies": { "follow-redirects": "^1.10.0" }, "deprecated": false, "description": "Promise based HTTP client for the browser and node.js", "devDependencies": { "bundlesize": "^0.17.0", "coveralls": "^3.0.0", "es6-promise": "^4.2.4", "grunt": "^1.0.2", "grunt-banner": "^0.6.0", "grunt-cli": "^1.2.0", "grunt-contrib-clean": "^1.1.0", "grunt-contrib-watch": "^1.0.0", "grunt-eslint": "^20.1.0", "grunt-karma": "^2.0.0", "grunt-mocha-test": "^0.13.3", "grunt-ts": "^6.0.0-beta.19", "grunt-webpack": "^1.0.18", "istanbul-instrumenter-loader": "^1.0.0", "jasmine-core": "^2.4.1", "karma": "^1.3.0", "karma-chrome-launcher": "^2.2.0", "karma-coverage": "^1.1.1", "karma-firefox-launcher": "^1.1.0", "karma-jasmine": "^1.1.1", "karma-jasmine-ajax": "^0.1.13", "karma-opera-launcher": "^1.0.0", "karma-safari-launcher": "^1.0.0", "karma-sauce-launcher": "^1.2.0", "karma-sinon": "^1.0.5", "karma-sourcemap-loader": "^0.3.7", "karma-webpack": "^1.7.0", "load-grunt-tasks": "^3.5.2", "minimist": "^1.2.0", "mocha": "^5.2.0", "sinon": "^4.5.0", "typescript": "^2.8.1", "url-search-params": "^0.10.0", "webpack": "^1.13.1", "webpack-dev-server": "^1.14.1" }, "homepage": "https://github.com/axios/axios", "jsdelivr": "dist/axios.min.js", "keywords": ["xhr", "http", "ajax", "promise", "node"], "license": "MIT", "main": "index.js", "name": "axios", "repository": { "type": "git", "url": "git+https://github.com/axios/axios.git" }, "scripts": { "build": "NODE_ENV=production grunt build", "coveralls": "cat coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js", "examples": "node ./examples/server.js", "fix": "eslint --fix lib/**/*.js", "postversion": "git push && git push --tags", "preversion": "npm test", "start": "node ./sandbox/server.js", "test": "grunt test && bundlesize", "version": "npm run build && grunt version && git add -A dist && git add CHANGELOG.md bower.json package.json" }, "typings": "./index.d.ts", "unpkg": "dist/axios.min.js", "version": "0.20.0" };

        /***/
      }),

/***/ 369:
/***/ (function (module) {

        "use strict";


        /**
         * Update an Error with the specified config, error code, and response.
         *
         * @param {Error} error The error to update.
         * @param {Object} config The config.
         * @param {string} [code] The error code (for example, 'ECONNABORTED').
         * @param {Object} [request] The request.
         * @param {Object} [response] The response.
         * @returns {Error} The error.
         */
        module.exports = function enhanceError(error, config, code, request, response) {
          error.config = config;
          if (code) {
            error.code = code;
          }

          error.request = request;
          error.response = response;
          error.isAxiosError = true;

          error.toJSON = function toJSON() {
            return {
              // Standard
              message: this.message,
              name: this.name,
              // Microsoft
              description: this.description,
              number: this.number,
              // Mozilla
              fileName: this.fileName,
              lineNumber: this.lineNumber,
              columnNumber: this.columnNumber,
              stack: this.stack,
              // Axios
              config: this.config,
              code: this.code
            };
          };
          return error;
        };


        /***/
      }),

/***/ 411:
/***/ (function (module, __unusedexports, __webpack_require__) {

        "use strict";


        var utils = __webpack_require__(35);

        module.exports = function normalizeHeaderName(headers, normalizedName) {
          utils.forEach(headers, function processHeader(value, name) {
            if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
              headers[normalizedName] = value;
              delete headers[name];
            }
          });
        };


        /***/
      }),

/***/ 413:
/***/ (function (module) {

        module.exports = require("stream");

        /***/
      }),

/***/ 431:
/***/ (function (__unusedmodule, exports, __webpack_require__) {

        "use strict";

        var __importStar = (this && this.__importStar) || function (mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
          result["default"] = mod;
          return result;
        };
        Object.defineProperty(exports, "__esModule", { value: true });
        const os = __importStar(__webpack_require__(87));
        /**
         * Commands
         *
         * Command Format:
         *   ::name key=value,key=value::message
         *
         * Examples:
         *   ::warning::This is the message
         *   ::set-env name=MY_VAR::some value
         */
        function issueCommand(command, properties, message) {
          const cmd = new Command(command, properties, message);
          process.stdout.write(cmd.toString() + os.EOL);
        }
        exports.issueCommand = issueCommand;
        function issue(name, message = '') {
          issueCommand(name, {}, message);
        }
        exports.issue = issue;
        const CMD_STRING = '::';
        class Command {
          constructor(command, properties, message) {
            if (!command) {
              command = 'missing.command';
            }
            this.command = command;
            this.properties = properties;
            this.message = message;
          }
          toString() {
            let cmdStr = CMD_STRING + this.command;
            if (this.properties && Object.keys(this.properties).length > 0) {
              cmdStr += ' ';
              let first = true;
              for (const key in this.properties) {
                if (this.properties.hasOwnProperty(key)) {
                  const val = this.properties[key];
                  if (val) {
                    if (first) {
                      first = false;
                    }
                    else {
                      cmdStr += ',';
                    }
                    cmdStr += `${key}=${escapeProperty(val)}`;
                  }
                }
              }
            }
            cmdStr += `${CMD_STRING}${escapeData(this.message)}`;
            return cmdStr;
          }
        }
        /**
         * Sanitizes an input into a string so it can be passed into issueCommand safely
         * @param input input to sanitize into a string
         */
        function toCommandValue(input) {
          if (input === null || input === undefined) {
            return '';
          }
          else if (typeof input === 'string' || input instanceof String) {
            return input;
          }
          return JSON.stringify(input);
        }
        exports.toCommandValue = toCommandValue;
        function escapeData(s) {
          return toCommandValue(s)
            .replace(/%/g, '%25')
            .replace(/\r/g, '%0D')
            .replace(/\n/g, '%0A');
        }
        function escapeProperty(s) {
          return toCommandValue(s)
            .replace(/%/g, '%25')
            .replace(/\r/g, '%0D')
            .replace(/\n/g, '%0A')
            .replace(/:/g, '%3A')
            .replace(/,/g, '%2C');
        }
        //# sourceMappingURL=command.js.map

        /***/
      }),

/***/ 454:
/***/ (function (module, __unusedexports, __webpack_require__) {

        var debug;
        try {
          /* eslint global-require: off */
          debug = __webpack_require__(944)("follow-redirects");
        }
        catch (error) {
          debug = function () { /* */ };
        }
        module.exports = debug;


        /***/
      }),

/***/ 470:
/***/ (function (__unusedmodule, exports, __webpack_require__) {

        "use strict";

        var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
          function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
          return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
          });
        };
        var __importStar = (this && this.__importStar) || function (mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
          result["default"] = mod;
          return result;
        };
        Object.defineProperty(exports, "__esModule", { value: true });
        const command_1 = __webpack_require__(431);
        const os = __importStar(__webpack_require__(87));
        const path = __importStar(__webpack_require__(622));
        /**
         * The code to exit an action
         */
        var ExitCode;
        (function (ExitCode) {
          /**
           * A code indicating that the action was successful
           */
          ExitCode[ExitCode["Success"] = 0] = "Success";
          /**
           * A code indicating that the action was a failure
           */
          ExitCode[ExitCode["Failure"] = 1] = "Failure";
        })(ExitCode = exports.ExitCode || (exports.ExitCode = {}));
        //-----------------------------------------------------------------------
        // Variables
        //-----------------------------------------------------------------------
        /**
         * Sets env variable for this action and future actions in the job
         * @param name the name of the variable to set
         * @param val the value of the variable. Non-string values will be converted to a string via JSON.stringify
         */
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        function exportVariable(name, val) {
          const convertedVal = command_1.toCommandValue(val);
          process.env[name] = convertedVal;
          command_1.issueCommand('set-env', { name }, convertedVal);
        }
        exports.exportVariable = exportVariable;
        /**
         * Registers a secret which will get masked from logs
         * @param secret value of the secret
         */
        function setSecret(secret) {
          command_1.issueCommand('add-mask', {}, secret);
        }
        exports.setSecret = setSecret;
        /**
         * Prepends inputPath to the PATH (for this action and future actions)
         * @param inputPath
         */
        function addPath(inputPath) {
          command_1.issueCommand('add-path', {}, inputPath);
          process.env['PATH'] = `${inputPath}${path.delimiter}${process.env['PATH']}`;
        }
        exports.addPath = addPath;
        /**
         * Gets the value of an input.  The value is also trimmed.
         *
         * @param     name     name of the input to get
         * @param     options  optional. See InputOptions.
         * @returns   string
         */
        function getInput(name, options) {
          const val = process.env[`INPUT_${name.replace(/ /g, '_').toUpperCase()}`] || '';
          if (options && options.required && !val) {
            throw new Error(`Input required and not supplied: ${name}`);
          }
          return val.trim();
        }
        exports.getInput = getInput;
        /**
         * Sets the value of an output.
         *
         * @param     name     name of the output to set
         * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify
         */
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        function setOutput(name, value) {
          command_1.issueCommand('set-output', { name }, value);
        }
        exports.setOutput = setOutput;
        /**
         * Enables or disables the echoing of commands into stdout for the rest of the step.
         * Echoing is disabled by default if ACTIONS_STEP_DEBUG is not set.
         *
         */
        function setCommandEcho(enabled) {
          command_1.issue('echo', enabled ? 'on' : 'off');
        }
        exports.setCommandEcho = setCommandEcho;
        //-----------------------------------------------------------------------
        // Results
        //-----------------------------------------------------------------------
        /**
         * Sets the action status to failed.
         * When the action exits it will be with an exit code of 1
         * @param message add error issue message
         */
        function setFailed(message) {
          process.exitCode = ExitCode.Failure;
          error(message);
        }
        exports.setFailed = setFailed;
        //-----------------------------------------------------------------------
        // Logging Commands
        //-----------------------------------------------------------------------
        /**
         * Gets whether Actions Step Debug is on or not
         */
        function isDebug() {
          return process.env['RUNNER_DEBUG'] === '1';
        }
        exports.isDebug = isDebug;
        /**
         * Writes debug message to user log
         * @param message debug message
         */
        function debug(message) {
          command_1.issueCommand('debug', {}, message);
        }
        exports.debug = debug;
        /**
         * Adds an error issue
         * @param message error issue message. Errors will be converted to string via toString()
         */
        function error(message) {
          command_1.issue('error', message instanceof Error ? message.toString() : message);
        }
        exports.error = error;
        /**
         * Adds an warning issue
         * @param message warning issue message. Errors will be converted to string via toString()
         */
        function warning(message) {
          command_1.issue('warning', message instanceof Error ? message.toString() : message);
        }
        exports.warning = warning;
        /**
         * Writes info to log with console.log.
         * @param message info message
         */
        function info(message) {
          process.stdout.write(message + os.EOL);
        }
        exports.info = info;
        /**
         * Begin an output group.
         *
         * Output until the next `groupEnd` will be foldable in this group
         *
         * @param name The name of the output group
         */
        function startGroup(name) {
          command_1.issue('group', name);
        }
        exports.startGroup = startGroup;
        /**
         * End an output group.
         */
        function endGroup() {
          command_1.issue('endgroup');
        }
        exports.endGroup = endGroup;
        /**
         * Wrap an asynchronous function call in a group.
         *
         * Returns the same type as the function itself.
         *
         * @param name The name of the group
         * @param fn The function to wrap in the group
         */
        function group(name, fn) {
          return __awaiter(this, void 0, void 0, function* () {
            startGroup(name);
            let result;
            try {
              result = yield fn();
            }
            finally {
              endGroup();
            }
            return result;
          });
        }
        exports.group = group;
        //-----------------------------------------------------------------------
        // Wrapper action state
        //-----------------------------------------------------------------------
        /**
         * Saves state for current action, the state can only be retrieved by this action's post job execution.
         *
         * @param     name     name of the state to store
         * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify
         */
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        function saveState(name, value) {
          command_1.issueCommand('save-state', { name }, value);
        }
        exports.saveState = saveState;
        /**
         * Gets the value of an state set by this action's main execution.
         *
         * @param     name     name of the state to get
         * @returns   string
         */
        function getState(name) {
          return process.env[`STATE_${name}`] || '';
        }
        exports.getState = getState;
        //# sourceMappingURL=core.js.map

        /***/
      }),

/***/ 481:
/***/ (function (module, exports) {

        "use strict";
        /* humanize.js - v1.8.2 */


        var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

        /**
         * Copyright 2013-2016 HubSpotDev
         * MIT Licensed
         *
         * @module humanize.js
         */

        (function (root, factory) {
          if ((false ? undefined : _typeof(exports)) === 'object') {
            module.exports = factory();
          } else if (typeof define === 'function' && define.amd) {
            define([], function () {
              return root.Humanize = factory();
            });
          } else {
            root.Humanize = factory();
          }
        })(this, function () {
          //------------------------------------------------------------------------------
          // Constants
          //------------------------------------------------------------------------------

          var TIME_FORMATS = [{
            name: 'second',
            value: 1e3
          }, {
            name: 'minute',
            value: 6e4
          }, {
            name: 'hour',
            value: 36e5
          }, {
            name: 'day',
            value: 864e5
          }, {
            name: 'week',
            value: 6048e5
          }];

          var LABELS_FOR_POWERS_OF_KILO = {
            P: Math.pow(2, 50),
            T: Math.pow(2, 40),
            G: Math.pow(2, 30),
            M: Math.pow(2, 20)
          };

          //------------------------------------------------------------------------------
          // Helpers
          //------------------------------------------------------------------------------

          var exists = function exists(maybe) {
            return typeof maybe !== 'undefined' && maybe !== null;
          };

          var isNaN = function isNaN(value) {
            return value !== value;
          }; // eslint-disable-line

          var isFiniteNumber = function isFiniteNumber(value) {
            return isFinite(value) && !isNaN(parseFloat(value));
          };

          var isArray = function isArray(value) {
            var type = Object.prototype.toString.call(value);
            return type === '[object Array]';
          };

          //------------------------------------------------------------------------------
          // Humanize
          //------------------------------------------------------------------------------

          var Humanize = {

            // Converts a large integer to a friendly text representation.

            intword: function intword(number, charWidth) {
              var decimals = arguments.length <= 2 || arguments[2] === undefined ? 2 : arguments[2];

              /*
              * This method is deprecated. Please use compactInteger instead.
              * intword will be going away in the next major version.
              */
              return Humanize.compactInteger(number, decimals);
            },


            // Converts an integer into its most compact representation
            compactInteger: function compactInteger(input) {
              var decimals = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];

              decimals = Math.max(decimals, 0);
              var number = parseInt(input, 10);
              var signString = number < 0 ? '-' : '';
              var unsignedNumber = Math.abs(number);
              var unsignedNumberString = String(unsignedNumber);
              var numberLength = unsignedNumberString.length;
              var numberLengths = [13, 10, 7, 4];
              var bigNumPrefixes = ['T', 'B', 'M', 'k'];

              // small numbers
              if (unsignedNumber < 1000) {
                return '' + signString + unsignedNumberString;
              }

              // really big numbers
              if (numberLength > numberLengths[0] + 3) {
                return number.toExponential(decimals).replace('e+', 'x10^');
              }

              // 999 < unsignedNumber < 999,999,999,999,999
              var length = void 0;
              for (var i = 0; i < numberLengths.length; i++) {
                var _length = numberLengths[i];
                if (numberLength >= _length) {
                  length = _length;
                  break;
                }
              }

              var decimalIndex = numberLength - length + 1;
              var unsignedNumberCharacterArray = unsignedNumberString.split('');

              var wholePartArray = unsignedNumberCharacterArray.slice(0, decimalIndex);
              var decimalPartArray = unsignedNumberCharacterArray.slice(decimalIndex, decimalIndex + decimals + 1);

              var wholePart = wholePartArray.join('');

              // pad decimalPart if necessary
              var decimalPart = decimalPartArray.join('');
              if (decimalPart.length < decimals) {
                decimalPart += '' + Array(decimals - decimalPart.length + 1).join('0');
              }

              var output = void 0;
              if (decimals === 0) {
                output = '' + signString + wholePart + bigNumPrefixes[numberLengths.indexOf(length)];
              } else {
                var outputNumber = Number(wholePart + '.' + decimalPart).toFixed(decimals);
                output = '' + signString + outputNumber + bigNumPrefixes[numberLengths.indexOf(length)];
              }

              return output;
            },


            // Converts an integer to a string containing commas every three digits.
            intComma: function intComma(number) {
              var decimals = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];

              return Humanize.formatNumber(number, decimals);
            },
            intcomma: function intcomma() {
              return Humanize.intComma.apply(Humanize, arguments);
            },


            // Formats the value like a 'human-readable' file size (i.e. '13 KB', '4.1 MB', '102 bytes', etc).
            fileSize: function fileSize(filesize) {
              var precision = arguments.length <= 1 || arguments[1] === undefined ? 2 : arguments[1];

              for (var label in LABELS_FOR_POWERS_OF_KILO) {
                if (LABELS_FOR_POWERS_OF_KILO.hasOwnProperty(label)) {
                  var minnum = LABELS_FOR_POWERS_OF_KILO[label];
                  if (filesize >= minnum) {
                    return Humanize.formatNumber(filesize / minnum, precision, '') + ' ' + label + 'B';
                  }
                }
              }
              if (filesize >= 1024) {
                return Humanize.formatNumber(filesize / 1024, 0) + ' KB';
              }

              return Humanize.formatNumber(filesize, 0) + Humanize.pluralize(filesize, ' byte');
            },
            filesize: function filesize() {
              return Humanize.fileSize.apply(Humanize, arguments);
            },


            // Formats a number to a human-readable string.
            // Localize by overriding the precision, thousand and decimal arguments.
            formatNumber: function formatNumber(number) {
              var precision = arguments.length <= 1 || arguments[1] === undefined ? 0 : arguments[1];
              var thousand = arguments.length <= 2 || arguments[2] === undefined ? ',' : arguments[2];
              var decimal = arguments.length <= 3 || arguments[3] === undefined ? '.' : arguments[3];

              // Create some private utility functions to make the computational
              // code that follows much easier to read.
              var firstComma = function firstComma(_number, _thousand, _position) {
                return _position ? _number.substr(0, _position) + _thousand : '';
              };

              var commas = function commas(_number, _thousand, _position) {
                return _number.substr(_position).replace(/(\d{3})(?=\d)/g, '$1' + _thousand);
              };

              var decimals = function decimals(_number, _decimal, usePrecision) {
                return usePrecision ? _decimal + Humanize.toFixed(Math.abs(_number), usePrecision).split('.')[1] : '';
              };

              var usePrecision = Humanize.normalizePrecision(precision);

              // Do some calc
              var negative = number < 0 && '-' || '';
              var base = String(parseInt(Humanize.toFixed(Math.abs(number || 0), usePrecision), 10));
              var mod = base.length > 3 ? base.length % 3 : 0;

              // Format the number
              return negative + firstComma(base, thousand, mod) + commas(base, thousand, mod) + decimals(number, decimal, usePrecision);
            },


            // Fixes binary rounding issues (eg. (0.615).toFixed(2) === '0.61')
            toFixed: function toFixed(value, precision) {
              precision = exists(precision) ? precision : Humanize.normalizePrecision(precision, 0);
              var power = Math.pow(10, precision);

              // Multiply up by precision, round accurately, then divide and use native toFixed()
              return (Math.round(value * power) / power).toFixed(precision);
            },


            // Ensures precision value is a positive integer
            normalizePrecision: function normalizePrecision(value, base) {
              value = Math.round(Math.abs(value));
              return isNaN(value) ? base : value;
            },


            // Converts an integer to its ordinal as a string.
            ordinal: function ordinal(value) {
              var number = parseInt(value, 10);

              if (number === 0) {
                return value;
              }

              var specialCase = number % 100;
              if ([11, 12, 13].indexOf(specialCase) >= 0) {
                return number + 'th';
              }

              var leastSignificant = number % 10;

              var end = void 0;
              switch (leastSignificant) {
                case 1:
                  end = 'st';
                  break;
                case 2:
                  end = 'nd';
                  break;
                case 3:
                  end = 'rd';
                  break;
                default:
                  end = 'th';
              }

              return '' + number + end;
            },


            // Interprets numbers as occurences. Also accepts an optional array/map of overrides.
            times: function times(value) {
              var overrides = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

              if (isFiniteNumber(value) && value >= 0) {
                var number = parseFloat(value);
                var smallTimes = ['never', 'once', 'twice'];
                if (exists(overrides[number])) {
                  return String(overrides[number]);
                }

                var numberString = exists(smallTimes[number]) && smallTimes[number].toString();
                return numberString || number.toString() + ' times';
              }
              return null;
            },


            // Returns the plural version of a given word if the value is not 1. The default suffix is 's'.
            pluralize: function pluralize(number, singular, plural) {
              if (!(exists(number) && exists(singular))) {
                return null;
              }

              plural = exists(plural) ? plural : singular + 's';

              return parseInt(number, 10) === 1 ? singular : plural;
            },


            // Truncates a string if it is longer than the specified number of characters (inclusive).
            // Truncated strings will end with a translatable ellipsis sequence ("…").
            truncate: function truncate(str) {
              var length = arguments.length <= 1 || arguments[1] === undefined ? 100 : arguments[1];
              var ending = arguments.length <= 2 || arguments[2] === undefined ? '...' : arguments[2];

              if (str.length > length) {
                return str.substring(0, length - ending.length) + ending;
              }
              return str;
            },


            // Truncates a string after a certain number of words.
            truncateWords: function truncateWords(string, length) {
              var array = string.split(' ');
              var result = '';
              var i = 0;

              while (i < length) {
                if (exists(array[i])) {
                  result += array[i] + ' ';
                }
                i++;
              }

              if (array.length > length) {
                return result + '...';
              }

              return null;
            },
            truncatewords: function truncatewords() {
              return Humanize.truncateWords.apply(Humanize, arguments);
            },


            // Truncates a number to an upper bound.
            boundedNumber: function boundedNumber(num) {
              var bound = arguments.length <= 1 || arguments[1] === undefined ? 100 : arguments[1];
              var ending = arguments.length <= 2 || arguments[2] === undefined ? '+' : arguments[2];

              var result = void 0;

              if (isFiniteNumber(num) && isFiniteNumber(bound)) {
                if (num > bound) {
                  result = bound + ending;
                }
              }

              return (result || num).toString();
            },
            truncatenumber: function truncatenumber() {
              return Humanize.boundedNumber.apply(Humanize, arguments);
            },


            // Converts a list of items to a human readable string with an optional limit.
            oxford: function oxford(items, limit, limitStr) {
              var numItems = items.length;

              var limitIndex = void 0;
              if (numItems < 2) {
                return String(items);
              } else if (numItems === 2) {
                return items.join(' and ');
              } else if (exists(limit) && numItems > limit) {
                var extra = numItems - limit;
                limitIndex = limit;
                limitStr = exists(limitStr) ? limitStr : ', and ' + extra + ' ' + Humanize.pluralize(extra, 'other');
              } else {
                limitIndex = -1;
                limitStr = ', and ' + items[numItems - 1];
              }

              return items.slice(0, limitIndex).join(', ') + limitStr;
            },


            // Converts an object to a definition-like string
            dictionary: function dictionary(object) {
              var joiner = arguments.length <= 1 || arguments[1] === undefined ? ' is ' : arguments[1];
              var separator = arguments.length <= 2 || arguments[2] === undefined ? ', ' : arguments[2];

              var result = '';

              if (exists(object) && (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && !isArray(object)) {
                var defs = [];
                for (var key in object) {
                  if (object.hasOwnProperty(key)) {
                    var val = object[key];
                    defs.push('' + key + joiner + val);
                  }
                }

                return defs.join(separator);
              }

              return result;
            },


            // Describes how many times an item appears in a list
            frequency: function frequency(list, verb) {
              if (!isArray(list)) {
                return null;
              }

              var len = list.length;
              var times = Humanize.times(len);

              if (len === 0) {
                return times + ' ' + verb;
              }

              return verb + ' ' + times;
            },
            pace: function pace(value, intervalMs) {
              var unit = arguments.length <= 2 || arguments[2] === undefined ? 'time' : arguments[2];

              if (value === 0 || intervalMs === 0) {
                // Needs a better string than this...
                return 'No ' + Humanize.pluralize(0, unit);
              }

              // Expose these as overridables?
              var prefix = 'Approximately';
              var timeUnit = void 0;
              var relativePace = void 0;

              var rate = value / intervalMs;
              for (var i = 0; i < TIME_FORMATS.length; ++i) {
                // assumes sorted list
                var f = TIME_FORMATS[i];
                relativePace = rate * f.value;
                if (relativePace > 1) {
                  timeUnit = f.name;
                  break;
                }
              }

              // Use the last time unit if there is nothing smaller
              if (!timeUnit) {
                prefix = 'Less than';
                relativePace = 1;
                timeUnit = TIME_FORMATS[TIME_FORMATS.length - 1].name;
              }

              var roundedPace = Math.round(relativePace);
              unit = Humanize.pluralize(roundedPace, unit);

              return prefix + ' ' + roundedPace + ' ' + unit + ' per ' + timeUnit;
            },


            // Converts newlines to <br/> tags
            nl2br: function nl2br(string) {
              var replacement = arguments.length <= 1 || arguments[1] === undefined ? '<br/>' : arguments[1];

              return string.replace(/\n/g, replacement);
            },


            // Converts <br/> tags to newlines
            br2nl: function br2nl(string) {
              var replacement = arguments.length <= 1 || arguments[1] === undefined ? '\r\n' : arguments[1];

              return string.replace(/\<br\s*\/?\>/g, replacement);
            },


            // Capitalizes first letter in a string
            capitalize: function capitalize(string) {
              var downCaseTail = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];

              return '' + string.charAt(0).toUpperCase() + (downCaseTail ? string.slice(1).toLowerCase() : string.slice(1));
            },


            // Capitalizes the first letter of each word in a string
            capitalizeAll: function capitalizeAll(string) {
              return string.replace(/(?:^|\s)\S/g, function (a) {
                return a.toUpperCase();
              });
            },


            // Titlecase words in a string.
            titleCase: function titleCase(string) {
              var smallWords = /\b(a|an|and|at|but|by|de|en|for|if|in|of|on|or|the|to|via|vs?\.?)\b/i;
              var internalCaps = /\S+[A-Z]+\S*/;
              var splitOnWhiteSpaceRegex = /\s+/;
              var splitOnHyphensRegex = /-/;

              var _doTitleCase = void 0;
              _doTitleCase = function doTitleCase(_string) {
                var hyphenated = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
                var firstOrLast = arguments.length <= 2 || arguments[2] === undefined ? true : arguments[2];

                var titleCasedArray = [];
                var stringArray = _string.split(hyphenated ? splitOnHyphensRegex : splitOnWhiteSpaceRegex);

                for (var index = 0; index < stringArray.length; ++index) {
                  var word = stringArray[index];
                  if (word.indexOf('-') !== -1) {
                    titleCasedArray.push(_doTitleCase(word, true, index === 0 || index === stringArray.length - 1));
                    continue;
                  }

                  if (firstOrLast && (index === 0 || index === stringArray.length - 1)) {
                    titleCasedArray.push(internalCaps.test(word) ? word : Humanize.capitalize(word));
                    continue;
                  }

                  if (internalCaps.test(word)) {
                    titleCasedArray.push(word);
                  } else if (smallWords.test(word)) {
                    titleCasedArray.push(word.toLowerCase());
                  } else {
                    titleCasedArray.push(Humanize.capitalize(word));
                  }
                }

                return titleCasedArray.join(hyphenated ? '-' : ' ');
              };

              return _doTitleCase(string);
            },
            titlecase: function titlecase() {
              return Humanize.titleCase.apply(Humanize, arguments);
            }
          };

          return Humanize;
        });

        /***/
      }),

/***/ 529:
/***/ (function (module, __unusedexports, __webpack_require__) {

        "use strict";


        var utils = __webpack_require__(35);
        var normalizeHeaderName = __webpack_require__(411);

        var DEFAULT_CONTENT_TYPE = {
          'Content-Type': 'application/x-www-form-urlencoded'
        };

        function setContentTypeIfUnset(headers, value) {
          if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
            headers['Content-Type'] = value;
          }
        }

        function getDefaultAdapter() {
          var adapter;
          if (typeof XMLHttpRequest !== 'undefined') {
            // For browsers use XHR adapter
            adapter = __webpack_require__(219);
          } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
            // For node use HTTP adapter
            adapter = __webpack_require__(670);
          }
          return adapter;
        }

        var defaults = {
          adapter: getDefaultAdapter(),

          transformRequest: [function transformRequest(data, headers) {
            normalizeHeaderName(headers, 'Accept');
            normalizeHeaderName(headers, 'Content-Type');
            if (utils.isFormData(data) ||
              utils.isArrayBuffer(data) ||
              utils.isBuffer(data) ||
              utils.isStream(data) ||
              utils.isFile(data) ||
              utils.isBlob(data)
            ) {
              return data;
            }
            if (utils.isArrayBufferView(data)) {
              return data.buffer;
            }
            if (utils.isURLSearchParams(data)) {
              setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
              return data.toString();
            }
            if (utils.isObject(data)) {
              setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
              return JSON.stringify(data);
            }
            return data;
          }],

          transformResponse: [function transformResponse(data) {
            /*eslint no-param-reassign:0*/
            if (typeof data === 'string') {
              try {
                data = JSON.parse(data);
              } catch (e) { /* Ignore */ }
            }
            return data;
          }],

          /**
           * A timeout in milliseconds to abort a request. If set to 0 (default) a
           * timeout is not created.
           */
          timeout: 0,

          xsrfCookieName: 'XSRF-TOKEN',
          xsrfHeaderName: 'X-XSRF-TOKEN',

          maxContentLength: -1,
          maxBodyLength: -1,

          validateStatus: function validateStatus(status) {
            return status >= 200 && status < 300;
          }
        };

        defaults.headers = {
          common: {
            'Accept': 'application/json, text/plain, */*'
          }
        };

        utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
          defaults.headers[method] = {};
        });

        utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
          defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
        });

        module.exports = defaults;


        /***/
      }),

/***/ 549:
/***/ (function (module, __unusedexports, __webpack_require__) {

        var url = __webpack_require__(835);
        var URL = url.URL;
        var http = __webpack_require__(605);
        var https = __webpack_require__(211);
        var Writable = __webpack_require__(413).Writable;
        var assert = __webpack_require__(357);
        var debug = __webpack_require__(454);

        // Create handlers that pass events from native requests
        var eventHandlers = Object.create(null);
        ["abort", "aborted", "connect", "error", "socket", "timeout"].forEach(function (event) {
          eventHandlers[event] = function (arg1, arg2, arg3) {
            this._redirectable.emit(event, arg1, arg2, arg3);
          };
        });

        // Error types with codes
        var RedirectionError = createErrorType(
          "ERR_FR_REDIRECTION_FAILURE",
          ""
        );
        var TooManyRedirectsError = createErrorType(
          "ERR_FR_TOO_MANY_REDIRECTS",
          "Maximum number of redirects exceeded"
        );
        var MaxBodyLengthExceededError = createErrorType(
          "ERR_FR_MAX_BODY_LENGTH_EXCEEDED",
          "Request body larger than maxBodyLength limit"
        );
        var WriteAfterEndError = createErrorType(
          "ERR_STREAM_WRITE_AFTER_END",
          "write after end"
        );

        // An HTTP(S) request that can be redirected
        function RedirectableRequest(options, responseCallback) {
          // Initialize the request
          Writable.call(this);
          this._sanitizeOptions(options);
          this._options = options;
          this._ended = false;
          this._ending = false;
          this._redirectCount = 0;
          this._redirects = [];
          this._requestBodyLength = 0;
          this._requestBodyBuffers = [];

          // Attach a callback if passed
          if (responseCallback) {
            this.on("response", responseCallback);
          }

          // React to responses of native requests
          var self = this;
          this._onNativeResponse = function (response) {
            self._processResponse(response);
          };

          // Perform the first request
          this._performRequest();
        }
        RedirectableRequest.prototype = Object.create(Writable.prototype);

        // Writes buffered data to the current native request
        RedirectableRequest.prototype.write = function (data, encoding, callback) {
          // Writing is not allowed if end has been called
          if (this._ending) {
            throw new WriteAfterEndError();
          }

          // Validate input and shift parameters if necessary
          if (!(typeof data === "string" || typeof data === "object" && ("length" in data))) {
            throw new TypeError("data should be a string, Buffer or Uint8Array");
          }
          if (typeof encoding === "function") {
            callback = encoding;
            encoding = null;
          }

          // Ignore empty buffers, since writing them doesn't invoke the callback
          // https://github.com/nodejs/node/issues/22066
          if (data.length === 0) {
            if (callback) {
              callback();
            }
            return;
          }
          // Only write when we don't exceed the maximum body length
          if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
            this._requestBodyLength += data.length;
            this._requestBodyBuffers.push({ data: data, encoding: encoding });
            this._currentRequest.write(data, encoding, callback);
          }
          // Error when we exceed the maximum body length
          else {
            this.emit("error", new MaxBodyLengthExceededError());
            this.abort();
          }
        };

        // Ends the current native request
        RedirectableRequest.prototype.end = function (data, encoding, callback) {
          // Shift parameters if necessary
          if (typeof data === "function") {
            callback = data;
            data = encoding = null;
          }
          else if (typeof encoding === "function") {
            callback = encoding;
            encoding = null;
          }

          // Write data if needed and end
          if (!data) {
            this._ended = this._ending = true;
            this._currentRequest.end(null, null, callback);
          }
          else {
            var self = this;
            var currentRequest = this._currentRequest;
            this.write(data, encoding, function () {
              self._ended = true;
              currentRequest.end(null, null, callback);
            });
            this._ending = true;
          }
        };

        // Sets a header value on the current native request
        RedirectableRequest.prototype.setHeader = function (name, value) {
          this._options.headers[name] = value;
          this._currentRequest.setHeader(name, value);
        };

        // Clears a header value on the current native request
        RedirectableRequest.prototype.removeHeader = function (name) {
          delete this._options.headers[name];
          this._currentRequest.removeHeader(name);
        };

        // Global timeout for all underlying requests
        RedirectableRequest.prototype.setTimeout = function (msecs, callback) {
          if (callback) {
            this.once("timeout", callback);
          }

          if (this.socket) {
            startTimer(this, msecs);
          }
          else {
            var self = this;
            this._currentRequest.once("socket", function () {
              startTimer(self, msecs);
            });
          }

          this.once("response", clearTimer);
          this.once("error", clearTimer);

          return this;
        };

        function startTimer(request, msecs) {
          clearTimeout(request._timeout);
          request._timeout = setTimeout(function () {
            request.emit("timeout");
          }, msecs);
        }

        function clearTimer() {
          clearTimeout(this._timeout);
        }

        // Proxy all other public ClientRequest methods
        [
          "abort", "flushHeaders", "getHeader",
          "setNoDelay", "setSocketKeepAlive",
        ].forEach(function (method) {
          RedirectableRequest.prototype[method] = function (a, b) {
            return this._currentRequest[method](a, b);
          };
        });

        // Proxy all public ClientRequest properties
        ["aborted", "connection", "socket"].forEach(function (property) {
          Object.defineProperty(RedirectableRequest.prototype, property, {
            get: function () { return this._currentRequest[property]; },
          });
        });

        RedirectableRequest.prototype._sanitizeOptions = function (options) {
          // Ensure headers are always present
          if (!options.headers) {
            options.headers = {};
          }

          // Since http.request treats host as an alias of hostname,
          // but the url module interprets host as hostname plus port,
          // eliminate the host property to avoid confusion.
          if (options.host) {
            // Use hostname if set, because it has precedence
            if (!options.hostname) {
              options.hostname = options.host;
            }
            delete options.host;
          }

          // Complete the URL object when necessary
          if (!options.pathname && options.path) {
            var searchPos = options.path.indexOf("?");
            if (searchPos < 0) {
              options.pathname = options.path;
            }
            else {
              options.pathname = options.path.substring(0, searchPos);
              options.search = options.path.substring(searchPos);
            }
          }
        };


        // Executes the next native request (initial or redirect)
        RedirectableRequest.prototype._performRequest = function () {
          // Load the native protocol
          var protocol = this._options.protocol;
          var nativeProtocol = this._options.nativeProtocols[protocol];
          if (!nativeProtocol) {
            this.emit("error", new TypeError("Unsupported protocol " + protocol));
            return;
          }

          // If specified, use the agent corresponding to the protocol
          // (HTTP and HTTPS use different types of agents)
          if (this._options.agents) {
            var scheme = protocol.substr(0, protocol.length - 1);
            this._options.agent = this._options.agents[scheme];
          }

          // Create the native request
          var request = this._currentRequest =
            nativeProtocol.request(this._options, this._onNativeResponse);
          this._currentUrl = url.format(this._options);

          // Set up event handlers
          request._redirectable = this;
          for (var event in eventHandlers) {
            /* istanbul ignore else */
            if (event) {
              request.on(event, eventHandlers[event]);
            }
          }

          // End a redirected request
          // (The first request must be ended explicitly with RedirectableRequest#end)
          if (this._isRedirect) {
            // Write the request entity and end.
            var i = 0;
            var self = this;
            var buffers = this._requestBodyBuffers;
            (function writeNext(error) {
              // Only write if this request has not been redirected yet
              /* istanbul ignore else */
              if (request === self._currentRequest) {
                // Report any write errors
                /* istanbul ignore if */
                if (error) {
                  self.emit("error", error);
                }
                // Write the next buffer if there are still left
                else if (i < buffers.length) {
                  var buffer = buffers[i++];
                  /* istanbul ignore else */
                  if (!request.finished) {
                    request.write(buffer.data, buffer.encoding, writeNext);
                  }
                }
                // End the request if `end` has been called on us
                else if (self._ended) {
                  request.end();
                }
              }
            }());
          }
        };

        // Processes a response from the current native request
        RedirectableRequest.prototype._processResponse = function (response) {
          // Store the redirected response
          var statusCode = response.statusCode;
          if (this._options.trackRedirects) {
            this._redirects.push({
              url: this._currentUrl,
              headers: response.headers,
              statusCode: statusCode,
            });
          }

          // RFC7231§6.4: The 3xx (Redirection) class of status code indicates
          // that further action needs to be taken by the user agent in order to
          // fulfill the request. If a Location header field is provided,
          // the user agent MAY automatically redirect its request to the URI
          // referenced by the Location field value,
          // even if the specific status code is not understood.
          var location = response.headers.location;
          if (location && this._options.followRedirects !== false &&
            statusCode >= 300 && statusCode < 400) {
            // Abort the current request
            this._currentRequest.removeAllListeners();
            this._currentRequest.on("error", noop);
            this._currentRequest.abort();
            // Discard the remainder of the response to avoid waiting for data
            response.destroy();

            // RFC7231§6.4: A client SHOULD detect and intervene
            // in cyclical redirections (i.e., "infinite" redirection loops).
            if (++this._redirectCount > this._options.maxRedirects) {
              this.emit("error", new TooManyRedirectsError());
              return;
            }

            // RFC7231§6.4: Automatic redirection needs to done with
            // care for methods not known to be safe, […]
            // RFC7231§6.4.2–3: For historical reasons, a user agent MAY change
            // the request method from POST to GET for the subsequent request.
            if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" ||
              // RFC7231§6.4.4: The 303 (See Other) status code indicates that
              // the server is redirecting the user agent to a different resource […]
              // A user agent can perform a retrieval request targeting that URI
              // (a GET or HEAD request if using HTTP) […]
              (statusCode === 303) && !/^(?:GET|HEAD)$/.test(this._options.method)) {
              this._options.method = "GET";
              // Drop a possible entity and headers related to it
              this._requestBodyBuffers = [];
              removeMatchingHeaders(/^content-/i, this._options.headers);
            }

            // Drop the Host header, as the redirect might lead to a different host
            var previousHostName = removeMatchingHeaders(/^host$/i, this._options.headers) ||
              url.parse(this._currentUrl).hostname;

            // Create the redirected request
            var redirectUrl = url.resolve(this._currentUrl, location);
            debug("redirecting to", redirectUrl);
            this._isRedirect = true;
            var redirectUrlParts = url.parse(redirectUrl);
            Object.assign(this._options, redirectUrlParts);

            // Drop the Authorization header if redirecting to another host
            if (redirectUrlParts.hostname !== previousHostName) {
              removeMatchingHeaders(/^authorization$/i, this._options.headers);
            }

            // Evaluate the beforeRedirect callback
            if (typeof this._options.beforeRedirect === "function") {
              var responseDetails = { headers: response.headers };
              try {
                this._options.beforeRedirect.call(null, this._options, responseDetails);
              }
              catch (err) {
                this.emit("error", err);
                return;
              }
              this._sanitizeOptions(this._options);
            }

            // Perform the redirected request
            try {
              this._performRequest();
            }
            catch (cause) {
              var error = new RedirectionError("Redirected request failed: " + cause.message);
              error.cause = cause;
              this.emit("error", error);
            }
          }
          else {
            // The response is not a redirect; return it as-is
            response.responseUrl = this._currentUrl;
            response.redirects = this._redirects;
            this.emit("response", response);

            // Clean up
            this._requestBodyBuffers = [];
          }
        };

        // Wraps the key/value object of protocols with redirect functionality
        function wrap(protocols) {
          // Default settings
          var exports = {
            maxRedirects: 21,
            maxBodyLength: 10 * 1024 * 1024,
          };

          // Wrap each protocol
          var nativeProtocols = {};
          Object.keys(protocols).forEach(function (scheme) {
            var protocol = scheme + ":";
            var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
            var wrappedProtocol = exports[scheme] = Object.create(nativeProtocol);

            // Executes a request, following redirects
            wrappedProtocol.request = function (input, options, callback) {
              // Parse parameters
              if (typeof input === "string") {
                var urlStr = input;
                try {
                  input = urlToOptions(new URL(urlStr));
                }
                catch (err) {
                  /* istanbul ignore next */
                  input = url.parse(urlStr);
                }
              }
              else if (URL && (input instanceof URL)) {
                input = urlToOptions(input);
              }
              else {
                callback = options;
                options = input;
                input = { protocol: protocol };
              }
              if (typeof options === "function") {
                callback = options;
                options = null;
              }

              // Set defaults
              options = Object.assign({
                maxRedirects: exports.maxRedirects,
                maxBodyLength: exports.maxBodyLength,
              }, input, options);
              options.nativeProtocols = nativeProtocols;

              assert.equal(options.protocol, protocol, "protocol mismatch");
              debug("options", options);
              return new RedirectableRequest(options, callback);
            };

            // Executes a GET request, following redirects
            wrappedProtocol.get = function (input, options, callback) {
              var request = wrappedProtocol.request(input, options, callback);
              request.end();
              return request;
            };
          });
          return exports;
        }

        /* istanbul ignore next */
        function noop() { /* empty */ }

        // from https://github.com/nodejs/node/blob/master/lib/internal/url.js
        function urlToOptions(urlObject) {
          var options = {
            protocol: urlObject.protocol,
            hostname: urlObject.hostname.startsWith("[") ?
              /* istanbul ignore next */
              urlObject.hostname.slice(1, -1) :
              urlObject.hostname,
            hash: urlObject.hash,
            search: urlObject.search,
            pathname: urlObject.pathname,
            path: urlObject.pathname + urlObject.search,
            href: urlObject.href,
          };
          if (urlObject.port !== "") {
            options.port = Number(urlObject.port);
          }
          return options;
        }

        function removeMatchingHeaders(regex, headers) {
          var lastValue;
          for (var header in headers) {
            if (regex.test(header)) {
              lastValue = headers[header];
              delete headers[header];
            }
          }
          return lastValue;
        }

        function createErrorType(code, defaultMessage) {
          function CustomError(message) {
            Error.captureStackTrace(this, this.constructor);
            this.message = message || defaultMessage;
          }
          CustomError.prototype = new Error();
          CustomError.prototype.constructor = CustomError;
          CustomError.prototype.name = "Error [" + code + "]";
          CustomError.prototype.code = code;
          return CustomError;
        }

        // Exports
        module.exports = wrap({ http: http, https: https });
        module.exports.wrap = wrap;


        /***/
      }),

/***/ 564:
/***/ (function (module, __unusedexports, __webpack_require__) {

        "use strict";


        var createError = __webpack_require__(26);

        /**
         * Resolve or reject a Promise based on response status.
         *
         * @param {Function} resolve A function that resolves the promise.
         * @param {Function} reject A function that rejects the promise.
         * @param {object} response The response.
         */
        module.exports = function settle(resolve, reject, response) {
          var validateStatus = response.config.validateStatus;
          if (!response.status || !validateStatus || validateStatus(response.status)) {
            resolve(response);
          } else {
            reject(createError(
              'Request failed with status code ' + response.status,
              response.config,
              null,
              response.request,
              response
            ));
          }
        };


        /***/
      }),

/***/ 589:
/***/ (function (module, __unusedexports, __webpack_require__) {

        "use strict";


        var utils = __webpack_require__(35);

        /**
         * Transform the data for a request or a response
         *
         * @param {Object|String} data The data to be transformed
         * @param {Array} headers The headers for the request or response
         * @param {Array|Function} fns A single function or Array of functions
         * @returns {*} The resulting transformed data
         */
        module.exports = function transformData(data, headers, fns) {
          /*eslint no-param-reassign:0*/
          utils.forEach(fns, function transform(fn) {
            data = fn(data, headers);
          });

          return data;
        };


        /***/
      }),

/***/ 590:
/***/ (function (module) {

        "use strict";


        /**
         * Determines whether the specified URL is absolute
         *
         * @param {string} url The URL to test
         * @returns {boolean} True if the specified URL is absolute, otherwise false
         */
        module.exports = function isAbsoluteURL(url) {
          // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
          // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
          // by any combination of letters, digits, plus, period, or hyphen.
          return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
        };


        /***/
      }),

/***/ 605:
/***/ (function (module) {

        module.exports = require("http");

        /***/
      }),

/***/ 622:
/***/ (function (module) {

        module.exports = require("path");

        /***/
      }),

/***/ 631:
/***/ (function (module, __unusedexports, __webpack_require__) {

        "use strict";


        var utils = __webpack_require__(35);

        // Headers whose duplicates are ignored by node
        // c.f. https://nodejs.org/api/http.html#http_message_headers
        var ignoreDuplicateOf = [
          'age', 'authorization', 'content-length', 'content-type', 'etag',
          'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
          'last-modified', 'location', 'max-forwards', 'proxy-authorization',
          'referer', 'retry-after', 'user-agent'
        ];

        /**
         * Parse headers into an object
         *
         * ```
         * Date: Wed, 27 Aug 2014 08:58:49 GMT
         * Content-Type: application/json
         * Connection: keep-alive
         * Transfer-Encoding: chunked
         * ```
         *
         * @param {String} headers Headers needing to be parsed
         * @returns {Object} Headers parsed into an object
         */
        module.exports = function parseHeaders(headers) {
          var parsed = {};
          var key;
          var val;
          var i;

          if (!headers) { return parsed; }

          utils.forEach(headers.split('\n'), function parser(line) {
            i = line.indexOf(':');
            key = utils.trim(line.substr(0, i)).toLowerCase();
            val = utils.trim(line.substr(i + 1));

            if (key) {
              if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
                return;
              }
              if (key === 'set-cookie') {
                parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
              } else {
                parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
              }
            }
          });

          return parsed;
        };


        /***/
      }),

/***/ 670:
/***/ (function (module, __unusedexports, __webpack_require__) {

        "use strict";


        var utils = __webpack_require__(35);
        var settle = __webpack_require__(564);
        var buildFullPath = __webpack_require__(960);
        var buildURL = __webpack_require__(133);
        var http = __webpack_require__(605);
        var https = __webpack_require__(211);
        var httpFollow = __webpack_require__(549).http;
        var httpsFollow = __webpack_require__(549).https;
        var url = __webpack_require__(835);
        var zlib = __webpack_require__(761);
        var pkg = __webpack_require__(361);
        var createError = __webpack_require__(26);
        var enhanceError = __webpack_require__(369);

        var isHttps = /https:?/;

        /*eslint consistent-return:0*/
        module.exports = function httpAdapter(config) {
          return new Promise(function dispatchHttpRequest(resolvePromise, rejectPromise) {
            var resolve = function resolve(value) {
              resolvePromise(value);
            };
            var reject = function reject(value) {
              rejectPromise(value);
            };
            var data = config.data;
            var headers = config.headers;

            // Set User-Agent (required by some servers)
            // Only set header if it hasn't been set in config
            // See https://github.com/axios/axios/issues/69
            if (!headers['User-Agent'] && !headers['user-agent']) {
              headers['User-Agent'] = 'axios/' + pkg.version;
            }

            if (data && !utils.isStream(data)) {
              if (Buffer.isBuffer(data)) {
                // Nothing to do...
              } else if (utils.isArrayBuffer(data)) {
                data = Buffer.from(new Uint8Array(data));
              } else if (utils.isString(data)) {
                data = Buffer.from(data, 'utf-8');
              } else {
                return reject(createError(
                  'Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream',
                  config
                ));
              }

              // Add Content-Length header if data exists
              headers['Content-Length'] = data.length;
            }

            // HTTP basic authentication
            var auth = undefined;
            if (config.auth) {
              var username = config.auth.username || '';
              var password = config.auth.password || '';
              auth = username + ':' + password;
            }

            // Parse url
            var fullPath = buildFullPath(config.baseURL, config.url);
            var parsed = url.parse(fullPath);
            var protocol = parsed.protocol || 'http:';

            if (!auth && parsed.auth) {
              var urlAuth = parsed.auth.split(':');
              var urlUsername = urlAuth[0] || '';
              var urlPassword = urlAuth[1] || '';
              auth = urlUsername + ':' + urlPassword;
            }

            if (auth) {
              delete headers.Authorization;
            }

            var isHttpsRequest = isHttps.test(protocol);
            var agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;

            var options = {
              path: buildURL(parsed.path, config.params, config.paramsSerializer).replace(/^\?/, ''),
              method: config.method.toUpperCase(),
              headers: headers,
              agent: agent,
              agents: { http: config.httpAgent, https: config.httpsAgent },
              auth: auth
            };

            if (config.socketPath) {
              options.socketPath = config.socketPath;
            } else {
              options.hostname = parsed.hostname;
              options.port = parsed.port;
            }

            var proxy = config.proxy;
            if (!proxy && proxy !== false) {
              var proxyEnv = protocol.slice(0, -1) + '_proxy';
              var proxyUrl = process.env[proxyEnv] || process.env[proxyEnv.toUpperCase()];
              if (proxyUrl) {
                var parsedProxyUrl = url.parse(proxyUrl);
                var noProxyEnv = process.env.no_proxy || process.env.NO_PROXY;
                var shouldProxy = true;

                if (noProxyEnv) {
                  var noProxy = noProxyEnv.split(',').map(function trim(s) {
                    return s.trim();
                  });

                  shouldProxy = !noProxy.some(function proxyMatch(proxyElement) {
                    if (!proxyElement) {
                      return false;
                    }
                    if (proxyElement === '*') {
                      return true;
                    }
                    if (proxyElement[0] === '.' &&
                      parsed.hostname.substr(parsed.hostname.length - proxyElement.length) === proxyElement) {
                      return true;
                    }

                    return parsed.hostname === proxyElement;
                  });
                }


                if (shouldProxy) {
                  proxy = {
                    host: parsedProxyUrl.hostname,
                    port: parsedProxyUrl.port
                  };

                  if (parsedProxyUrl.auth) {
                    var proxyUrlAuth = parsedProxyUrl.auth.split(':');
                    proxy.auth = {
                      username: proxyUrlAuth[0],
                      password: proxyUrlAuth[1]
                    };
                  }
                }
              }
            }

            if (proxy) {
              options.hostname = proxy.host;
              options.host = proxy.host;
              options.headers.host = parsed.hostname + (parsed.port ? ':' + parsed.port : '');
              options.port = proxy.port;
              options.path = protocol + '//' + parsed.hostname + (parsed.port ? ':' + parsed.port : '') + options.path;

              // Basic proxy authorization
              if (proxy.auth) {
                var base64 = Buffer.from(proxy.auth.username + ':' + proxy.auth.password, 'utf8').toString('base64');
                options.headers['Proxy-Authorization'] = 'Basic ' + base64;
              }
            }

            var transport;
            var isHttpsProxy = isHttpsRequest && (proxy ? isHttps.test(proxy.protocol) : true);
            if (config.transport) {
              transport = config.transport;
            } else if (config.maxRedirects === 0) {
              transport = isHttpsProxy ? https : http;
            } else {
              if (config.maxRedirects) {
                options.maxRedirects = config.maxRedirects;
              }
              transport = isHttpsProxy ? httpsFollow : httpFollow;
            }

            if (config.maxBodyLength > -1) {
              options.maxBodyLength = config.maxBodyLength;
            }

            // Create the request
            var req = transport.request(options, function handleResponse(res) {
              if (req.aborted) return;

              // uncompress the response body transparently if required
              var stream = res;

              // return the last request in case of redirects
              var lastRequest = res.req || req;


              // if no content, is HEAD request or decompress disabled we should not decompress
              if (res.statusCode !== 204 && lastRequest.method !== 'HEAD' && config.decompress !== false) {
                switch (res.headers['content-encoding']) {
                  /*eslint default-case:0*/
                  case 'gzip':
                  case 'compress':
                  case 'deflate':
                    // add the unzipper to the body stream processing pipeline
                    stream = stream.pipe(zlib.createUnzip());

                    // remove the content-encoding in order to not confuse downstream operations
                    delete res.headers['content-encoding'];
                    break;
                }
              }

              var response = {
                status: res.statusCode,
                statusText: res.statusMessage,
                headers: res.headers,
                config: config,
                request: lastRequest
              };

              if (config.responseType === 'stream') {
                response.data = stream;
                settle(resolve, reject, response);
              } else {
                var responseBuffer = [];
                stream.on('data', function handleStreamData(chunk) {
                  responseBuffer.push(chunk);

                  // make sure the content length is not over the maxContentLength if specified
                  if (config.maxContentLength > -1 && Buffer.concat(responseBuffer).length > config.maxContentLength) {
                    stream.destroy();
                    reject(createError('maxContentLength size of ' + config.maxContentLength + ' exceeded',
                      config, null, lastRequest));
                  }
                });

                stream.on('error', function handleStreamError(err) {
                  if (req.aborted) return;
                  reject(enhanceError(err, config, null, lastRequest));
                });

                stream.on('end', function handleStreamEnd() {
                  var responseData = Buffer.concat(responseBuffer);
                  if (config.responseType !== 'arraybuffer') {
                    responseData = responseData.toString(config.responseEncoding);
                    if (!config.responseEncoding || config.responseEncoding === 'utf8') {
                      responseData = utils.stripBOM(responseData);
                    }
                  }

                  response.data = responseData;
                  settle(resolve, reject, response);
                });
              }
            });

            // Handle errors
            req.on('error', function handleRequestError(err) {
              if (req.aborted && err.code !== 'ERR_FR_TOO_MANY_REDIRECTS') return;
              reject(enhanceError(err, config, null, req));
            });

            // Handle request timeout
            if (config.timeout) {
              // Sometime, the response will be very slow, and does not respond, the connect event will be block by event loop system.
              // And timer callback will be fired, and abort() will be invoked before connection, then get "socket hang up" and code ECONNRESET.
              // At this time, if we have a large number of request, nodejs will hang up some socket on background. and the number will up and up.
              // And then these socket which be hang up will devoring CPU little by little.
              // ClientRequest.setTimeout will be fired on the specify milliseconds, and can make sure that abort() will be fired after connect.
              req.setTimeout(config.timeout, function handleRequestTimeout() {
                req.abort();
                reject(createError('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED', req));
              });
            }

            if (config.cancelToken) {
              // Handle cancellation
              config.cancelToken.promise.then(function onCanceled(cancel) {
                if (req.aborted) return;

                req.abort();
                reject(cancel);
              });
            }

            // Send the request
            if (utils.isStream(data)) {
              data.on('error', function handleStreamError(err) {
                reject(enhanceError(err, config, null, req));
              }).pipe(req);
            } else {
              req.end(data);
            }
          });
        };


        /***/
      }),

/***/ 688:
/***/ (function (module, __unusedexports, __webpack_require__) {

        "use strict";


        var utils = __webpack_require__(35);

        module.exports = (
          utils.isStandardBrowserEnv() ?

            // Standard browser envs have full support of the APIs needed to test
            // whether the request URL is of the same origin as current location.
            (function standardBrowserEnv() {
              var msie = /(msie|trident)/i.test(navigator.userAgent);
              var urlParsingNode = document.createElement('a');
              var originURL;

              /**
            * Parse a URL to discover it's components
            *
            * @param {String} url The URL to be parsed
            * @returns {Object}
            */
              function resolveURL(url) {
                var href = url;

                if (msie) {
                  // IE needs attribute set twice to normalize properties
                  urlParsingNode.setAttribute('href', href);
                  href = urlParsingNode.href;
                }

                urlParsingNode.setAttribute('href', href);

                // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
                return {
                  href: urlParsingNode.href,
                  protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
                  host: urlParsingNode.host,
                  search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
                  hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
                  hostname: urlParsingNode.hostname,
                  port: urlParsingNode.port,
                  pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
                    urlParsingNode.pathname :
                    '/' + urlParsingNode.pathname
                };
              }

              originURL = resolveURL(window.location.href);

              /**
            * Determine if a URL shares the same origin as the current location
            *
            * @param {String} requestURL The URL to test
            * @returns {boolean} True if URL shares the same origin, otherwise false
            */
              return function isURLSameOrigin(requestURL) {
                var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
                return (parsed.protocol === originURL.protocol &&
                  parsed.host === originURL.host);
              };
            })() :

            // Non standard browser envs (web workers, react-native) lack needed support.
            (function nonStandardBrowserEnv() {
              return function isURLSameOrigin() {
                return true;
              };
            })()
        );


        /***/
      }),

/***/ 727:
/***/ (function (module) {

        "use strict";


        module.exports = function bind(fn, thisArg) {
          return function wrap() {
            var args = new Array(arguments.length);
            for (var i = 0; i < args.length; i++) {
              args[i] = arguments[i];
            }
            return fn.apply(thisArg, args);
          };
        };


        /***/
      }),

/***/ 732:
/***/ (function (module) {

        "use strict";


        module.exports = function isCancel(value) {
          return !!(value && value.__CANCEL__);
        };


        /***/
      }),

/***/ 747:
/***/ (function (module) {

        module.exports = require("fs");

        /***/
      }),

/***/ 761:
/***/ (function (module) {

        module.exports = require("zlib");

        /***/
      }),

/***/ 779:
/***/ (function (module, __unusedexports, __webpack_require__) {

        "use strict";


        var utils = __webpack_require__(35);
        var buildURL = __webpack_require__(133);
        var InterceptorManager = __webpack_require__(283);
        var dispatchRequest = __webpack_require__(946);
        var mergeConfig = __webpack_require__(825);

        /**
         * Create a new instance of Axios
         *
         * @param {Object} instanceConfig The default config for the instance
         */
        function Axios(instanceConfig) {
          this.defaults = instanceConfig;
          this.interceptors = {
            request: new InterceptorManager(),
            response: new InterceptorManager()
          };
        }

        /**
         * Dispatch a request
         *
         * @param {Object} config The config specific for this request (merged with this.defaults)
         */
        Axios.prototype.request = function request(config) {
          /*eslint no-param-reassign:0*/
          // Allow for axios('example/url'[, config]) a la fetch API
          if (typeof config === 'string') {
            config = arguments[1] || {};
            config.url = arguments[0];
          } else {
            config = config || {};
          }

          config = mergeConfig(this.defaults, config);

          // Set config.method
          if (config.method) {
            config.method = config.method.toLowerCase();
          } else if (this.defaults.method) {
            config.method = this.defaults.method.toLowerCase();
          } else {
            config.method = 'get';
          }

          // Hook up interceptors middleware
          var chain = [dispatchRequest, undefined];
          var promise = Promise.resolve(config);

          this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
            chain.unshift(interceptor.fulfilled, interceptor.rejected);
          });

          this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
            chain.push(interceptor.fulfilled, interceptor.rejected);
          });

          while (chain.length) {
            promise = promise.then(chain.shift(), chain.shift());
          }

          return promise;
        };

        Axios.prototype.getUri = function getUri(config) {
          config = mergeConfig(this.defaults, config);
          return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
        };

        // Provide aliases for supported request methods
        utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
          /*eslint func-names:0*/
          Axios.prototype[method] = function (url, config) {
            return this.request(mergeConfig(config || {}, {
              method: method,
              url: url
            }));
          };
        });

        utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
          /*eslint func-names:0*/
          Axios.prototype[method] = function (url, data, config) {
            return this.request(mergeConfig(config || {}, {
              method: method,
              url: url,
              data: data
            }));
          };
        });

        module.exports = Axios;


        /***/
      }),

/***/ 825:
/***/ (function (module, __unusedexports, __webpack_require__) {

        "use strict";


        var utils = __webpack_require__(35);

        /**
         * Config-specific merge-function which creates a new config-object
         * by merging two configuration objects together.
         *
         * @param {Object} config1
         * @param {Object} config2
         * @returns {Object} New object resulting from merging config2 to config1
         */
        module.exports = function mergeConfig(config1, config2) {
          // eslint-disable-next-line no-param-reassign
          config2 = config2 || {};
          var config = {};

          var valueFromConfig2Keys = ['url', 'method', 'data'];
          var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy', 'params'];
          var defaultToConfig2Keys = [
            'baseURL', 'transformRequest', 'transformResponse', 'paramsSerializer',
            'timeout', 'timeoutMessage', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName',
            'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress', 'decompress',
            'maxContentLength', 'maxBodyLength', 'maxRedirects', 'transport', 'httpAgent',
            'httpsAgent', 'cancelToken', 'socketPath', 'responseEncoding'
          ];
          var directMergeKeys = ['validateStatus'];

          function getMergedValue(target, source) {
            if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
              return utils.merge(target, source);
            } else if (utils.isPlainObject(source)) {
              return utils.merge({}, source);
            } else if (utils.isArray(source)) {
              return source.slice();
            }
            return source;
          }

          function mergeDeepProperties(prop) {
            if (!utils.isUndefined(config2[prop])) {
              config[prop] = getMergedValue(config1[prop], config2[prop]);
            } else if (!utils.isUndefined(config1[prop])) {
              config[prop] = getMergedValue(undefined, config1[prop]);
            }
          }

          utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
            if (!utils.isUndefined(config2[prop])) {
              config[prop] = getMergedValue(undefined, config2[prop]);
            }
          });

          utils.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);

          utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
            if (!utils.isUndefined(config2[prop])) {
              config[prop] = getMergedValue(undefined, config2[prop]);
            } else if (!utils.isUndefined(config1[prop])) {
              config[prop] = getMergedValue(undefined, config1[prop]);
            }
          });

          utils.forEach(directMergeKeys, function merge(prop) {
            if (prop in config2) {
              config[prop] = getMergedValue(config1[prop], config2[prop]);
            } else if (prop in config1) {
              config[prop] = getMergedValue(undefined, config1[prop]);
            }
          });

          var axiosKeys = valueFromConfig2Keys
            .concat(mergeDeepPropertiesKeys)
            .concat(defaultToConfig2Keys)
            .concat(directMergeKeys);

          var otherKeys = Object
            .keys(config1)
            .concat(Object.keys(config2))
            .filter(function filterAxiosKeys(key) {
              return axiosKeys.indexOf(key) === -1;
            });

          utils.forEach(otherKeys, mergeDeepProperties);

          return config;
        };


        /***/
      }),

/***/ 826:
/***/ (function (module) {

        "use strict";


        /**
         * A `Cancel` is an object that is thrown when an operation is canceled.
         *
         * @class
         * @param {string=} message The message.
         */
        function Cancel(message) {
          this.message = message;
        }

        Cancel.prototype.toString = function toString() {
          return 'Cancel' + (this.message ? ': ' + this.message : '');
        };

        Cancel.prototype.__CANCEL__ = true;

        module.exports = Cancel;


        /***/
      }),

/***/ 835:
/***/ (function (module) {

        module.exports = require("url");

        /***/
      }),

/***/ 864:
/***/ (function (module, __unusedexports, __webpack_require__) {

        "use strict";


        var utils = __webpack_require__(35);

        module.exports = (
          utils.isStandardBrowserEnv() ?

            // Standard browser envs support document.cookie
            (function standardBrowserEnv() {
              return {
                write: function write(name, value, expires, path, domain, secure) {
                  var cookie = [];
                  cookie.push(name + '=' + encodeURIComponent(value));

                  if (utils.isNumber(expires)) {
                    cookie.push('expires=' + new Date(expires).toGMTString());
                  }

                  if (utils.isString(path)) {
                    cookie.push('path=' + path);
                  }

                  if (utils.isString(domain)) {
                    cookie.push('domain=' + domain);
                  }

                  if (secure === true) {
                    cookie.push('secure');
                  }

                  document.cookie = cookie.join('; ');
                },

                read: function read(name) {
                  var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
                  return (match ? decodeURIComponent(match[3]) : null);
                },

                remove: function remove(name) {
                  this.write(name, '', Date.now() - 86400000);
                }
              };
            })() :

            // Non standard browser env (web workers, react-native) lack needed support.
            (function nonStandardBrowserEnv() {
              return {
                write: function write() { },
                read: function read() { return null; },
                remove: function remove() { }
              };
            })()
        );


        /***/
      }),

/***/ 879:
/***/ (function (module) {

        "use strict";


        /**
         * Syntactic sugar for invoking a function and expanding an array for arguments.
         *
         * Common use case would be to use `Function.prototype.apply`.
         *
         *  ```js
         *  function f(x, y, z) {}
         *  var args = [1, 2, 3];
         *  f.apply(null, args);
         *  ```
         *
         * With `spread` this example can be re-written.
         *
         *  ```js
         *  spread(function(x, y, z) {})([1, 2, 3]);
         *  ```
         *
         * @param {Function} callback
         * @returns {Function}
         */
        module.exports = function spread(callback) {
          return function wrap(arr) {
            return callback.apply(null, arr);
          };
        };


        /***/
      }),

/***/ 887:
/***/ (function (module) {

        "use strict";


        /**
         * Creates a new URL by combining the specified URLs
         *
         * @param {string} baseURL The base URL
         * @param {string} relativeURL The relative URL
         * @returns {string} The combined URL
         */
        module.exports = function combineURLs(baseURL, relativeURL) {
          return relativeURL
            ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
            : baseURL;
        };


        /***/
      }),

/***/ 898:
/***/ (function (module, __unusedexports, __webpack_require__) {

        const { spawn } = __webpack_require__(129);

        const exec = (cmd, args = [], options = {}) => new Promise((resolve, reject) => {
          console.log(`Started: ${cmd} ${args.join(' ')}`);
          const optionsToCLI = {
            ...options
          };
          if (!optionsToCLI.stdio) {
            Object.assign(optionsToCLI, { stdio: ['inherit', 'inherit', 'inherit'] });
          }
          const app = spawn(cmd, args, optionsToCLI);
          app.on('close', (code) => {
            if (code !== 0) {
              const err = new Error(`Invalid status code: ${code}`);
              err.code = code;
              return reject(err);
            }
            return resolve(code);
          });
          app.on('error', reject);
        });

        module.exports = exec;

        /***/
      }),

/***/ 944:
/***/ (function (module) {

        module.exports = eval("require")("debug");


        /***/
      }),

/***/ 946:
/***/ (function (module, __unusedexports, __webpack_require__) {

        "use strict";


        var utils = __webpack_require__(35);
        var transformData = __webpack_require__(589);
        var isCancel = __webpack_require__(732);
        var defaults = __webpack_require__(529);

        /**
         * Throws a `Cancel` if cancellation has been requested.
         */
        function throwIfCancellationRequested(config) {
          if (config.cancelToken) {
            config.cancelToken.throwIfRequested();
          }
        }

        /**
         * Dispatch a request to the server using the configured adapter.
         *
         * @param {object} config The config that is to be used for the request
         * @returns {Promise} The Promise to be fulfilled
         */
        module.exports = function dispatchRequest(config) {
          throwIfCancellationRequested(config);

          // Ensure headers exist
          config.headers = config.headers || {};

          // Transform request data
          config.data = transformData(
            config.data,
            config.headers,
            config.transformRequest
          );

          // Flatten headers
          config.headers = utils.merge(
            config.headers.common || {},
            config.headers[config.method] || {},
            config.headers
          );

          utils.forEach(
            ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
            function cleanHeaderConfig(method) {
              delete config.headers[method];
            }
          );

          var adapter = config.adapter || defaults.adapter;

          return adapter(config).then(function onAdapterResolution(response) {
            throwIfCancellationRequested(config);

            // Transform response data
            response.data = transformData(
              response.data,
              response.headers,
              config.transformResponse
            );

            return response;
          }, function onAdapterRejection(reason) {
            if (!isCancel(reason)) {
              throwIfCancellationRequested(config);

              // Transform response data
              if (reason && reason.response) {
                reason.response.data = transformData(
                  reason.response.data,
                  reason.response.headers,
                  config.transformResponse
                );
              }
            }

            return Promise.reject(reason);
          });
        };


        /***/
      }),

/***/ 960:
/***/ (function (module, __unusedexports, __webpack_require__) {

        "use strict";


        var isAbsoluteURL = __webpack_require__(590);
        var combineURLs = __webpack_require__(887);

        /**
         * Creates a new URL by combining the baseURL with the requestedURL,
         * only when the requestedURL is not already an absolute URL.
         * If the requestURL is absolute, this function returns the requestedURL untouched.
         *
         * @param {string} baseURL The base URL
         * @param {string} requestedURL Absolute or relative URL to combine
         * @returns {string} The combined full path
         */
        module.exports = function buildFullPath(baseURL, requestedURL) {
          if (baseURL && !isAbsoluteURL(requestedURL)) {
            return combineURLs(baseURL, requestedURL);
          }
          return requestedURL;
        };


        /***/
      })

    /******/
  });